<html>
	<head>
		<title>
			Michael Cooper's Blog
		</title>
		<style>
			p.ex1 {
                   font: italic bold 42px/50px Georgia, serif;
                   color : white;
    			   background-color: rgba(100, 170, 100, 1);
			}
			p.ex2 {
    			  font: 16px Georgia, sans-serif;
            }
            p.ex3 {
    			font: 18px Georgia, sans-serif;
    			color : white  ;
    			background-color: green;
			}
		</style>
	</head>

	<body>
		<div>
			<p class="ex2">
				CSCi 3081W </br>
				Spring 2016 </br>
				FlashPhoto Project </br>
			</p class = "ex2">
			<a href="../programblog.html" class = "page"> Go back </a>
			<p class="ex1">
				Michael Cooper's Blog
			</p class="ex1">
						<ul>
				<li >ID : 2998234</li>
				<li>Email: coop0244@umn.edu</li>
			</ul>
		</div>

		<div>
			<h2>FlashPhoto Iteration 3 </h2>
		</div>

		<div>
			<p>May 6th, 2016</p>
			<a href="../programblog.html" class = "page"> Go back </a>
		

					<p class="ex3">What have I done?</p class="ex3">
					<p>
					 &#9;I, along with Simin, was assigned the refactoring of the two applications use a libphoto library.  I also helped with the testing, 
					 by coming up with and coding a solution for testing the interactive tools in FlashPhoto.
					</p>


					<p class="ex3">Makefiles</p class="ex3">
					<p>
					 &#9;
					</p>
<xmp>

PHOTO = photo

...

PHOTO_PATH = ./libphoto

...

PHOTO_LIB = $(PHOTO_PATH)/lib$(PHOTO).a

...

INCLUDE += -I$(PHOTO_PATH)/src

...

LINK_LIBS +=  -L$(PHOTO_PATH)/ -l$(PHOTO)

</xmp>

					<p>
					 &#9; This is an example of using macros to help build a source path so that we could link the libphoto library within FlashPhoto and Mia.  
					 The use of macros helps grant flexibility to the makefiles so that if we want to change certain things in the future, we don't need to hunt 
					 down every instance of what it is we're changing, we can simply change the macro and it will automatically make all necessary changes.
					</p>

<xmp>

$(FLASHPHOTO): $(GLUI_LIB) $(PNG_LIB) $(JPEG_LIB) $(LIBPHOTO_LIB)
	$(MAKE) -C $(FLASHPHOTO_PATH)

$(MIA): $(GLUI_LIB) $(PNG_LIB) $(JPEG_LIB) $(LIBPHOTO_LIB)
	$(MAKE) -C $(MIA_PATH)

$(TEST): 
	$(MAKE) -C $(TEST_PATH)

</xmp>

<p>
&#9;These commands were placed within our main makefile.  They target the makefiles of FlashPhoto, Mia, and tests.  This simplifies the creation of 
both applications, as well as the execution of tests, into a single command (make), which is very clean, simple and convenient.
</p>
					<p class="ex3">Testing the interactive tools</p class="ex3">
					<p>
					 &#9;In order to test the interactive tools in FlashPhoto, initially I thought we could test for an extra 'test' argument, so that if someone 
ran the command "./FlashPhoto test", the program would simply test the tools and quit.  For our final design, we decided it might be simpler to 
separate out an special instance of the application that simply ran the tests and quit. </br></br>

I also wrote the initial code to generate the interactive tool images to be tested with mia:</br>
					</p>
<xmp>
void testFlashPhoto::runTests()
{
	for (int i=0; i<8; i++)
	{
		if (i != 5)
		{
			testTool(i);
		}
	}
	exit(0);
}




void testFlashPhoto::testTool(int index)
{
	/** 
	 * Load the background image as canvas.
	 */
	loadCanvasEnabled(true);
	if (index == 7)
	{
		m_fileName = "images/in0.png";
		loadImageToCanvas();
	}
	
	/** 
	 * Load the stamp when we use the stamp tool.
	 */
	if (index == 6)
	{
		loadStampEnabled(true);
		m_fileName = "images/colorCircles.png";
		loadImageToStamp();
		m_curColorRed = 1.0;
		m_curColorGreen = 1.0;
		m_curColorBlue = 1.0;
	}

	/** 
	 * Determine the tool and determine a start position to draw.
	 */
	m_curTool = index;
	leftMouseDown(200,200);

	/** 
	 * Drag a line by using different tools.
	 */
	if (index == 1)
	{
		m_curTool = 0;
		leftMouseDown(200,200);
		mouseDragged(220,220);
		mouseDragged(240,240);
		mouseDragged(260,260);
		mouseDragged(280,280);
		mouseDragged(300,300);
		mouseDragged(320,320);
		mouseDragged(340,340);
		mouseDragged(360,360);
		leftMouseUp(360,360);
		
		m_curTool = index;
		leftMouseDown(200,200);
		mouseDragged(220,220);
		mouseDragged(240,240);
		mouseDragged(260,260);
		mouseDragged(280,280);
		leftMouseUp(280,280);
	}
	
	else if (index == 2 || index == 7)
	{
		mouseDragged(220,220);
		mouseDragged(225,225);
		mouseDragged(230,230);
		mouseDragged(235,235);
		mouseDragged(240,240);
		mouseDragged(245,245);
		mouseDragged(250,250);
		mouseDragged(255,255);
		mouseDragged(260,260);
		mouseDragged(265,265);
		mouseDragged(270,270);
		mouseDragged(275,275);
		mouseDragged(280,280);
		mouseDragged(285,285);
		mouseDragged(290,290);
		mouseDragged(295,295);
		mouseDragged(300,300);
		leftMouseUp(300,300);
	}
	
	else if (index == 6)
	{
		mouseDragged(220,220);
		leftMouseUp(220,220);
	}
	
	else
	{
		mouseDragged(220,220);
		mouseDragged(240,240);
		mouseDragged(260,260);
		mouseDragged(280,280);
		mouseDragged(300,300);
		mouseDragged(320,320);
		mouseDragged(340,340);
		mouseDragged(360,360);
		leftMouseUp(360,360);
	}

	/** 
	 * Save the completed images as the output images.
	 */
	saveCanvasEnabled(true);
	m_fileName = std::string("images/")+name(index);
	saveCanvasToFile();

	initializeBuffers(ColorData(1,1,0.95),400,400);

	loadCanvasEnabled(false);
	loadStampEnabled(false);
	saveCanvasEnabled(false);
}



std::string testFlashPhoto::name(int index)
{
	std::string name = "out2";
	std::stringstream n;
	n << index;
	name += n.str() + ".png";
	return name;
}
</xmp>
				<p>
				(Some of the code has been modified by Cheng)</br></br></br></br>
				
				The program iterates through the tools, calling the leftMouseDown and mouseDragged methods to draw onto a canvas, before using 
				ImageHandler to save the canvas, and then creating a fresh canvas for the next tool to draw on.  
				</p>


				<p class="ex3">My feeling after Iteration 3</p class="ex3">
				<p>
					 &#9; Overall, I enjoyed this project a lot.  Prior to this class, I hadn't actually been involved in a real life application of this size, 
					 that actually did some neat things.  Most of the coding assignments in previous classes have been smaller and more academic.<br><br>
					 
					 This project gave us many opportunities to apply the knowledge of design that we learned throughout the semester in 3081w.  Since we learned a lot 
					 of this stuff for the first time (at least for me), it was sometimes a challenge to design aspects of the program in a smart, clean way, and 
					 avoid falling into the "code as you go" habit that novice programmers are certainly prone to.  I can say, though, that I feel my skill as a programmer and a computer 
					 scientist has grown tremendously throughout this semester, which is great!
				</p>
		</div>
		<a href="../programblog.html" class = "page"> Go back to Program Blog Page</a>
	</body>

</html>
